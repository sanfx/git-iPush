#! /usr/bin/env python
# -*-coding: utf8-*-
# file: git-ipush
# command: git ipush

import argparse
import getpass
import keyring
import logging
import re
import subprocess
import sys
import tempfile
import mailer.send as send
from os import path

v = open(path.join(path.split(path.dirname(__file__))[0], 'VERSION'))
VERSION = v.readline().strip()
v.close()


def __validate_address(address):
	"""	If address looks like a valid e-mail address, return it. Otherwise
		raise ArgumentTypeError.

		Args:
			address(string): email address to send to

	"""
	if re.match('^([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})$', address):
		return address
	raise argparse.ArgumentTypeError('Invalid e-mail address: %s' % address)

def main(appName):
	parser = argparse.ArgumentParser(prog=appName,
		description='Utility to push the last commit and email the color diff')
	parser.add_argument('-v', '--verbose', action='store_true', 
		help='if enabled will spit every command and its resulting data.')
	parser.add_argument('-c', '--compose', action='store_true', 
		help='compose message in default git editor to be sent prefixed with diff')
	parser.add_argument('-to', type=__validate_address, metavar='Email',
		help='enter a valid email you want to send to.', nargs='?')
	parser.add_argument('-V', '--version', action='version',
		version="%s Ver: %s %s " % ( parser.prog, VERSION, parser.description))
	parser.add_argument('-p', '--patches', type=int, default=0, metavar='*.patch files',
		help='total number of pathces of last commits to email')
	parser.add_argument('-d', '--diff', required=False, default='HEAD^ HEAD',
		metavar='HEAD^ HEAD', help='if present pass arguments to it as you \
		will do to git diff in inverted commas')

	args = parser.parse_args()
	logging.basicConfig(level=logging.DEBUG)
	logger = logging.getLogger(appName)
	logger.setLevel(logging.DEBUG)
	__preCheck(args, logger)

def __updateConfig(log, key, value):
	"""	Function to update the global config git file.
		Args:
			key(string): key of the git command
			value(string): value of the key
	"""
	_execGitCommand(log, 'git config --global %s %s' % (key, value))


def _guarantee_bool(function):
	"""	A decorator that guarantees a true/false response.
	"""
	def wrapper(*args, **kargs):
		try:
			return bool(function(*args, **kargs))
		except:
			return False
	return wrapper

def configDb(log):
	"""	Reads git global config file

		Returns:
			config(dict): git config settings
	"""
	# Read git config file
	configFile, _ = _execGitCommand(log, 'git config --list')
	config = {}
	for line in (_line for _line in configFile.split("\n") if _line):
		config[line.split("=")[0]] = line.split("=")[-1]

	return config

def launchEditor(editor):
	"""	this function launchs the default git editor
		set in git config for user to compose message
		to be sent along with git diff.

		Args:
			editor(str): name or path of editor
		Returns:
			msg(str): html formatted message
	"""

	with tempfile.NamedTemporaryFile(delete=False) as f:
		f.close()
		if "-" in editor and editor not in ['vi', 'vim', 'nano', 'emacs']:
			editor = re.sub(" -.*", "", editor)
			openToEdit = [editor, f.name]
			if re.search('Sublime', editor):
				openToEdit = [editor, '-w', f.name]
		else:
			openToEdit = [editor, f.name]

		if subprocess.call(openToEdit) != 0:
			raise IOError("%s exited with code." % (editor.split(" ")[0]))
		msg = ''
		with open(f.name) as temp_file:
			temp_file.seek(0)
			for line in temp_file.readlines():
				msg += line

			return "".join(msg).replace("\n", "<br>")

def setUpIpush(log, config):
	"""	this function prompts user to enter email settings
		for this git ipush command to store in .gitconfig
		while password is stored in os keychain.

		Args:
			config(dict): existing config from .gitconfig
	"""
	# check if data in  global config
	if not config.has_key('ipush.mailfrom'):
		log.info("\x1b[32mFirst time mail setup.\x1b[m")
		log.warning("Do you want to use your git email to send diffs or any other email address ?")
		ret = raw_input('[YES]')
		if ret.lower() in ['', 'yes', 'y']:
			ret = config['user.email']
			__updateConfig(log, 'ipush.mailfrom', ret)
		else:
			ret = __validate_address(ret)
			_execGitCommand(log, 'git ipush.mailfrom %s' % ret)
		__updateConfig(log, 'ipush.mailfrom', ret)
		emailPwd = getpass.getpass(prompt=" Password: ")
		keyring.set_password('ipush', ret, emailPwd)
	# enter SMTP details for sending emails
	if not config.has_key('ipush.smtpserver'):
		log.info("Add SMTP details for '%s'.", ret)
		smtpServer = raw_input(" SMTP Server: ")
		__updateConfig(log, 'ipush.smtpserver', smtpServer)
		smtpServerPort = raw_input(" SMTP Server Port: ")
		__updateConfig(log, 'ipush.smtpserverport', smtpServerPort)
		smtpEncryption = raw_input(" Server Encryption: ")
		__updateConfig(log, 'ipush.smtpencryption', smtpEncryption)
	return True

def __preCheck(args, log):
	"""	This function do a pre-check of the repository state
		and default value to variables from git config

		Args:
			args(argparse.Namespace): data from git config
	"""
	config = configDb(log)

	editor = config['core.editor'] if config.has_key('core.editor') else 'vi'

	VERBOSE = args.verbose

	diffCmd = 'git diff %s' % args.diff

	branchName, _ = _execGitCommand(log, 'git rev-parse --abbrev-ref HEAD')

	if not branchName:
		return

	# stripping newline character which got appended when pulling branch name
	branchName = branchName.split("\n")[0]
	commitComment, _ = _execGitCommand(log, 'git log -1 --pretty=%B')
	subject = "%s: %s" % (branchName, commitComment)

	# check for fatal error when executing git command
	diffData, error = _execGitCommand(log, diffCmd, VERBOSE)
	if 'fatal' not in error.split(":"):
		modifiedData, error = _execGitCommand(log, 'git status', VERBOSE)
		if any([re.search(word, modifiedData) for word in ['modified', 'untracked']]):
			log.warning('You have uncommited changes, Commit and try again')
			return

		cmtMesgs, _ = _execGitCommand(log, 'git log origin/%s..HEAD --decorate --oneline' % branchName)
		if cmtMesgs:
			unPushComit = [cmits for cmits in cmtMesgs.split("\n") if cmits]
			log.info('Initiating push for %s commits listed below to remote %s\n\n%s',
				len(unPushComit), 
				branchName, 
				cmtMesgs)

		# only push that is displayed or the last commit
		if diffCmd in ['git diff HEAD^ HEAD', 'git diff HEAD~ HEAD']:
			isPushed = __pushBranch(log, VERBOSE)

			if isPushed:
				name, _ = _execGitCommand(log, 'git format-patch -%s' % args.patches)
				patches = [item for item in name.split("\n") if item]
				if diffData:
					message = ""
					if args.compose:
						message = launchEditor(editor)

					htmlDiff = getHtml(diffData.split("\n"))
					remotePath, _ = _execGitCommand(log, 'git config --get remote.origin.url')
					message = "%s<br>git clone %s<br><br>%s" % (message, remotePath, htmlDiff)

					updateComplete = setUpIpush(log, config)
					if updateComplete:
						# update the user email info by reading config again
						config = configDb(log)

					mailto = args.to if args.to else raw_input(
						"Who do you want to send to? ")

					__emailDiff(log, subject, mailto, message, patches)
	else:
		log.error(error.capitalize())

def colorText(color, text):
	colorCodes = {
		'black':'30',
		'red':'31',
		'green':'32',
		'yellow' :'33',
		'blue':'34',
		'magenta' :'35',
		'cyan' :'36',
 		'white ' :'37',
		}

	return "\x1b[%sm%s\x1b[m" % (colorCodes[color], text)

def getHtml(diffData):
	"""	This method convertes git diff data to html color code

		Args:
			diffData(sting): diff between commits in simple text
	"""
	openTag = """<span style='font-size:1.0em; color: """
	openTagEnd = ";font-family: courier, arial, helvetica, sans-serif;'>"
	nbsp = '&nbsp;&nbsp;&nbsp;&nbsp;'
	lines = []

	for line in diffData:
		color = "#ff0000" if line.startswith('-') else (
			'#007900' if line.startswith('+') else (
			'#B4009E' if line.startswith('@@') else '#000000'))
		tabs = line.count('\t')
		lines.append("%s%s%s%s%s</span><br>" % 
			((openTag, color, openTagEnd, nbsp*tabs, line)))
	return ''.join(lines)


def _execGitCommand(log, command=None, verbose=False):
	"""	Function used to get data out of git commads
		and errors in case of failure.

		Args:
			command(string): string of a git command
			verbose(bool): whether to display every command
			and its resulting data.
		Return:
			(tuple): string of Data and error if present
	"""
	if command:
		# converts multiple spaces to single space
		command = re.sub(' +',' ',command)
		pr = subprocess.Popen(command, shell=True,
			stdout=subprocess.PIPE, stderr=subprocess.PIPE)
		msg = pr.stdout.read()
		err = pr.stderr.read()
		if err:
			log.error(err)
			if 'Could not resolve host' in err:
				return
		if verbose and msg:
			log.info("Executing '%s' %s", command, msg)
		return msg, err

def __emailDiff(log, subject, emailTo, htmlDiff, attachment):
	""" This function send color diff via email

		Args:
			subject(string): name of the branch with commit message
			htmlDiff(string): html formatted string
			attachment(list): list of file names to be attached
	"""
	# add tool signature
	htmlDiff = """%s<br><br>
	Sent using git ipush<br>
	git clone https://sanfx@bitbucket.org/sanfx/git-ipush.git""" % htmlDiff
	emailInfo = configDb(log)
	pwd = str(keyring.get_password('ipush', emailInfo['ipush.mailfrom']))
	mail = send.EMail(
						mailfrom=emailInfo['ipush.mailfrom'], 
						server=emailInfo['ipush.smtpserver'], 
						usrname=emailInfo['ipush.mailfrom'].split('@')[0],
						password=pwd,
						logger=log,
						debug=False
					)
	try:
		emailTo = __validate_address(emailTo)
	except argparse.ArgumentTypeError as er:
		log.error("%s. Message not sent.", er)
	else:
		isSent = mail.sendMessage(subject, htmlDiff, attachment, emailTo)
		if isSent:
			msg = ' Diff of branch, %s sent to email: %s .' % (subject, emailTo)
			log.info(msg)

@_guarantee_bool
def __pushBranch(log, VERBOSE):
	"""	Pushes the branch to remote repository

		Args:
			VERBOSE(bool): defines whether to spit out which command
			is being executed and result of command.
		Return:
			(bool) True if push Succesfull else False 
	"""

	_, err = _execGitCommand(log, 'git push', True)

	if err.split("\n")[0] == 'Everything up-to-date':
		log.warning("Do you want to continue?")
		option = raw_input(['YES'])
		if option.lower() in ['', 'y', 'yes']:
			return True
		else:
			return False

	if re.search(r'rejected', err):
		txt = '\x1b[31mDo you want to try force push?\n'
		log.warning('%s%sEnter \'git push -f\' to force Push else any key to cancel\x1b[m',err, txt)
		# default value yes and hit enter without entering anything
		answer = raw_input('>>')
		if answer and answer.lower() not in ['yes', 'y', 'f', 'git push -f']:
			log.info("Cancelled !!!")
		else:
			_execGitCommand(log, 'git push -f', True)
			return True
	else:
		if not err:
			log.info("\x1b[33mPush Succesfull !\x1b[m" if VERBOSE else "")
		return True
	return False


if __name__ == '__main__':
	appName = sys.argv[0].split("-")[-1]
	sys.exit(main(appName))
